.program motor_exec

; FIFO Protocol
;
; Start (per round):
;   Word 0: DIR (bit0)
;
; Each command (3 words):
;   Word 1: delay_count        (>=0)  low-time / interval loop count
;   Word 2: steps              (>=0)  number of pulses
;   Word 3: pulse_high_cycles  (>=0)  high-time loop count
;
; End of round:
;   delay_count == 0 AND steps == 0   (pulse_high ignored)

.wrap_target
    ; ========= 初始化：设置 DIR =========
    pull block
    out  pins, 1        ; bit0 -> DIR (OUT pins base)

wait_cmd:
    ; ========= 读取 delay_count =========
    pull block
    mov  isr, osr       ; isr = delay_count

    ; ========= 读取 steps =========
    pull block
    mov  y, osr         ; y = steps

    ; ========= 读取 pulse_high（保存在 OSR）=========
    pull block          ; osr = pulse_high_cycles

    ; ========= 分支：steps==0 ? =========
check_steps:
    mov  x, y
    jmp  !x check_end_or_skip   ; steps == 0 -> 看是否 (delay==0 && steps==0)

    ; steps > 0：先把 steps 预减 1，然后进入一次脉冲
    jmp  y-- do_pulse            ; y = y - 1 (因为 y!=0 一定会跳)

do_pulse:
    ; ===== STEP 上升沿 =====
    set  pins, 1

    ; ===== 高电平宽度（OSR: pulse_high）=====
    mov  x, osr
high_loop:
    nop
    jmp  x-- high_loop

    ; ===== STEP 下降沿 =====
    set  pins, 0

    ; ===== 低电平/间隔延时（ISR: delay_count）=====
    mov  x, isr
delay_loop:
    nop
    jmp  x-- delay_loop

    ; 下一次脉冲
    jmp  check_steps

check_end_or_skip:
    ; steps==0 时走到这里：
    ; 若 delay==0 && steps==0 -> 本轮结束，等待下一次 DIR
    ; 否则仅跳过本条命令（不给脉冲），继续读下一条
    mov  x, isr
    jmp  !x wait_init            ; delay==0 && steps==0
    jmp  wait_cmd                ; steps==0 但 delay!=0：跳过本条命令

